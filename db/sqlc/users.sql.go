// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO USERS (
    user_id,
    FRIST_NAME,
    LAST_NAME,
    EMAIL,
    PHONE_NUMBER,
    PASSWORD_HASH,
    ROLE,
    STATUS
) VALUES(
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING user_id, frist_name, last_name, email, phone_number, password_hash, role, status, created_at, updated_at
`

type CreateUserParams struct {
	UserID       uuid.UUID `json:"user_id"`
	FristName    string    `json:"frist_name"`
	LastName     string    `json:"last_name"`
	Email        string    `json:"email"`
	PhoneNumber  string    `json:"phone_number"`
	PasswordHash []byte    `json:"password_hash"`
	Role         string    `json:"role"`
	Status       string    `json:"status"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.UserID,
		arg.FristName,
		arg.LastName,
		arg.Email,
		arg.PhoneNumber,
		arg.PasswordHash,
		arg.Role,
		arg.Status,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.FristName,
		&i.LastName,
		&i.Email,
		&i.PhoneNumber,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    user_id, frist_name, last_name, email, phone_number, password_hash, role, status, created_at, updated_at
FROM 
    USERS
WHERE
    email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.FristName,
		&i.LastName,
		&i.Email,
		&i.PhoneNumber,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resetEmail = `-- name: ResetEmail :exec
UPDATE USERS
SET
    EMAIL = $2,
    UPDATED_AT = NOW()
WHERE
    phone_number = $1
`

type ResetEmailParams struct {
	PhoneNumber string `json:"phone_number"`
	Email       string `json:"email"`
}

func (q *Queries) ResetEmail(ctx context.Context, arg ResetEmailParams) error {
	_, err := q.db.Exec(ctx, resetEmail, arg.PhoneNumber, arg.Email)
	return err
}

const resetPassword = `-- name: ResetPassword :exec
UPDATE USERS
SET
    PASSWORD_HASH = $2,
    UPDATED_AT = NOW()
WHERE
    EMAIL = $1
`

type ResetPasswordParams struct {
	Email        string `json:"email"`
	PasswordHash []byte `json:"password_hash"`
}

func (q *Queries) ResetPassword(ctx context.Context, arg ResetPasswordParams) error {
	_, err := q.db.Exec(ctx, resetPassword, arg.Email, arg.PasswordHash)
	return err
}

const resetPhoneNumber = `-- name: ResetPhoneNumber :exec
UPDATE USERS
SET
    phone_number = $2,
    UPDATED_AT = NOW()
WHERE
    EMAIL = $1
`

type ResetPhoneNumberParams struct {
	Email       string `json:"email"`
	PhoneNumber string `json:"phone_number"`
}

func (q *Queries) ResetPhoneNumber(ctx context.Context, arg ResetPhoneNumberParams) error {
	_, err := q.db.Exec(ctx, resetPhoneNumber, arg.Email, arg.PhoneNumber)
	return err
}

const userLogin = `-- name: UserLogin :one
SELECT
    PASSWORD_HASH,
    ROLE
FROM 
    USERS
WHERE
    EMAIL = $1 LIMIT 1
`

type UserLoginRow struct {
	PasswordHash []byte `json:"password_hash"`
	Role         string `json:"role"`
}

func (q *Queries) UserLogin(ctx context.Context, email string) (UserLoginRow, error) {
	row := q.db.QueryRow(ctx, userLogin, email)
	var i UserLoginRow
	err := row.Scan(&i.PasswordHash, &i.Role)
	return i, err
}
